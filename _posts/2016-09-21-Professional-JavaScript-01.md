---
layout: post
title:  "JavaScript红皮书精要（系列一）"
date:   2016/9/21 8:23:06
categories: original
excerpt_separator:   
---

这个系列是把JavaScript高级程序设计中我认为比较精华的部分做一总结整理，一来方便自己查询遗漏的点，二来也给没有时间看书的朋友提供一个比较精简的速看版本

### <span id="GoodeParts01"></span>1、引用类型 ###

引用类型的值（对象）是引用类型的一个**实例**

- 新对象就是使用**new**操作符后跟一个**构造函数**来创建的
- 构造函数本身就是一个函数：目的是创建对象

引用类型也被称为**对象定义**，因为他们描述的是一类对象所具有的**属性和方法**

#### <span id="GoodeParts01_01"></span>> Obeject类型 ####

> 大多数引用类型值都是Object类型的实例

**一、创建Object实例的方式（2种）：**

1、使用new操作符后跟Object构造函数

    var person = new Object();
	person.name = "pwnny";
	person.age = 21;

2、使用**对象字面量**表示法

    var person = {
		name : "pwnny",
		age : 21
	};

- 使用逗号分隔不同的属性，最后一个值后面不能添加逗号
- 右花括号 **}** 后要有一个分号 **;**
- 属性名也可以使用字符串`"name" : "pwnny", "age" : 21`（有数值属性名会自动转换为字符串 `5 : true`）

**定义只包含默认属性和方法的对象：**

    var person = {};	//与new Object()相同

> 通过对象字面量定义对象时，不会调用Object构造函数

**二、访问对象属性方法：**

1、使用**点**表示法

    console.log(person.name);	//"pwnny"

2、使用**方括号**表示法

    console.log(person["name"]);	//"pwnny"

> 使用方括号表示法，应该将要访问的属性以**字符串**的形式放在方括号中

**优点：**

    var propertyName = "name";
	console.log(person[propertyName]);	//"pwnny"

    person["first name"] = "pwnny";

- 可以通过变量访问属性
- 如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括号表示法

> 除非必须使用**变量**来访问属性，否则建议用点表示法

#### <span id="GoodeParts01_02"></span>> Array类型 ####

> 数组的每一项都可以保存**任何类型**的数据

> 数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容纳新数据

**一、创建数组的基本方式（2种）：**

1、使用Array构造函数

    var colors = new Array();	//直接使用Array构造函数
	var colors = new Array(20);	//如果预先知道数组数量，可以给构造函数传递该数量，传递的数量会自动变成length属性的值
	var colors = new Array("red", "black", "white");	//也可以传递数组中应该包含的项
	
*>传递一个值也可以创建数组，但分两种情况：*

    var colors = new Array(3);	//创建一个包含3项的数组
	var names = new Array("pwnny");		//创建一个包含1项，即字符串"pwnny"的数组

*>也可以省略new操作符：*

    var colors = new Array(3);	//创建一个包含3项的数组
	var names = new Array("pwnny");		//创建一个包含1项，即字符串"pwnny"的数组

2、使用数组字面量表示法

> 数组字面量由一对包含数组项的方括号表示，多个数组项之间以逗号隔开

    var colors = ["red", "black", "white"];	//创建一个包含3个字符串的数组
	var names = [];	//创建一个空数组
	var values = [1, 2, ];	//！创建一个包含2或3项的数组
	var options = [ , , , , , ];	//！创建一个包含5或6项的数组

后两行在IE8之前版本中，会成为一个包含3项，每项分别为1、2和undefined的数组以及一个包含6项，每项都是undefined的数组。在其他浏览器中则为包含1、2两项和包含5项undefined的数组

这是IE8之前版本中存在的bug，所以强烈建议不要使用后两项那种写法

> 使用数组字面量表示法，也不会调用Array构造函数

**二、读取设置数组：**

- 使用方括号并提供**基于0**的数字索引
	- 如果索引小于数组项数，则返回对应项的值 `console.log(colors[0]);`
	- 修改指定位置值 `colors[2] = "orange";`
	- 如果索引大于数组项数，数组就会自动增加到该索引值加1的长度 `colors[10] = "pink";	//数组长度11，数组第十一项的值为"pink"`
- 数组项数保存在**length**属性中，该属性始终返回0或更大的值（不是只读的）
	-  设置length可以从数组末尾移除项
		-  如一开始colors数组长度为3，设置其length为2 `colors.length = 2;`，则会移除最后一项（位置为2的），在访问colors[2]，就会显示undefined
	- 设置length可以向数组中添加新项
		- 如果将其length属性设置为大于数组项数的值 `colors.length = 4;`，则新增的每一项都会取得undefined值
	- 利用length可以方便的在数组末尾添加新项
		- `colors[colors.length] = "green";` 由于数组最后一项的索引始终是length-1，因此下一个新项的位置就是length。每当在数组末尾添加一项后，其length属性都会自动更新这一变化

**三、检测数组**

> 可以使用**instanceof：`value instanceof Array`**。但是如果一个网页中包含多个框架，就有多个全局执行环境，则从一个框架向另一个框架传入数组，那么传入的数组与在第二个框架中原生创建的数组分别具有不同的构造函数。那么就不能用instanceof来判断

可以使用**Array.isArray()**方法(**IE9+**)：目的是最终确定某个值到底是不是数组，不论他在哪个全局执行环境中创建

    if (Array.isArray(value)) {
		//对数组执行某些操作
	}

**四、转换方法**

    var colors = ["red", "black", "white"];
	console.log(colors.toString());		//red,blue,green
	console.log(colors.toLocalString());	//red,blue,green
	console.log(colors.valueOf());		//["red", "black", "white"]
	console.log(colors);	//["red", "black", "white"]
	alert(colors);		//red,blue,green

**toString()：**返回一个包含所有数组值的以逗号分隔的字符串

**toLocaleString()：**返回一个包含所有数组值的以逗号分隔的字符串（调用的是每一项的toLocaleString()方法而不是toString()方法）

**valueOf()：**返回的是一个数组

> 以上三种默认以逗号分隔

**join()：**可以指定不同的分隔符构建这个字符串

    var colors = ["red", "black", "white"];
	console.log(colors.join("||"));	//red||black||white 

- 接收一个参数，即作为分隔符的字符串
- 返回包含所有数组项的字符串
- 如果不给他传入任何值，或传入undefined，则使用逗号分隔
- IE7早期版本会错误的用字符串"undefined"作为分隔符

> 如果数组中的某一项是 **null** 或 **undefined**，那么该值在join()、toLocaleString()、toString()和valueOf()中返回结果还是 **null** 或 **undefined**

**五、栈方法**

- 栈是LIFO（Last-In-First-Out，后进先出）
- push()和pop()只发生在栈顶
- push()接收任意数量参数，把他们逐个添加到数组末尾，并**返回**修改后的数组长度
- pop()则从数组末尾移除最后一项，减少数组length值，然后**返回**移除的项
- push()和pop()是数组默认方法

**六、队列方法**

- 队列是FIFO（First-in-First-out，先进先出）
- push()在列表末端添加项，shift()在列表前端移除项
- shift()能够在数组前端移除第一项并**返回**该项，同时将数组长度减1
- ---
- 先进后出
- unshift()在列表前端添加项，pop()在列表末尾移除项
- unshift()能够在数组前端添加任意项，并**返回**新数组的长度

**七、重排序方法**

**reverse()：**反转数组项的顺序，**返回**经过排序之后的数组

**sort()：**按升序排列，小的在前大的在后，**返回**经过排序之后的数组

- 调用每个数组项的toString()转型方法 
- 比较得到的字符串，即使每一项是数值
- 所以[0,1,5,10,15]会变成[0,1,10,15,5]，因为字符串"10"在"5"之前

sort()可以接收一个**比较函数**作为参数，**比较函数**接收两个参数。

> 示例：

如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个之后则返回一个正数。

    function compare(value1, value2) {
		if (value1 < value2) {
			return -1;
		} else if (value1 > value2) {
			return 1;
		} else {
			return 0;
		}
	}

	var values = [0, 1, 5, 10, 15];	
	values.sort(compare);
	console.log(values);	//0,1,5,10,15

也可以交换比较函数产生降序排序效果：

    function compare(value1, value2) {
		if (value1 < value2) {
			return 1;
		} else if (value1 > value2) {
			return -1;
		} else {
			return 0;
		}
	}

	var values = [0, 1, 5, 10, 15];	
	values.sort(compare);
	console.log(values);	//15,10,5,1,0

对于**数值**类型或者其**valueOf()**方法会返回数值类型的对象类型，可以使用一个更简单的比较函数

    function compare(value1, value2) {
		return value2 - value1;
	}

**八、操作方法**

**concat()：**基于当前数组中的所有项创建一个新数组

- 先创建一个当前数组的副本，然后将收到的参数添加到这个副本的末尾，最后返回新创建的数组
- 没有参数的情况下，只是复制当前数组并返回副本
- 如果传递的是一或多个数组，则将这些数组中的每一项都添加到结果数组中
- 如果传递的不是数组，这些值就被简单的添加到结果数组的末尾

**slice()：**基于当前数组中的一或多个项创建一个新数组（不影响原数组）

- 接受一或两个参数，即要返回项的起始和结束位置
- 一个参数：返回从该指定位置到当前数组末尾的所有项
- 两个参数：返回起始和结束位置之间的项---不包括结束位置的项
- 参数中有一个负数，则用数组长度加上该数来确定相应的位置
	- 如在包含5项的数组上调用slice(-2,-1)与调用slice(3,4)得到的结果相同
- 如果结束为止小于起始位置，则返回空数组

**splice()：**向数组的中部插入项

- **删除：**可以删除任意数量的项，只需指定2个参数：要删除的第一项的位置和要删除的项数。如：splice(0,2)会删除数组中的前两项
- **插入：**可以向指定位置插入任意数量的项，只需提供3个参数：起始位置、0（要删除的项数）和要插入的项（要插入多项，可以再传入第四、第五以至任意多项）。如：splice(2,0,"red","green")会从当前数组的位置2开始插入字符串"red"和"green"
-  **替换：**可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定3个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。如：splice(2,1,"red","green")会删除当前数组位置2的项，然后再从位置2开始插入字符串"red"和"green"

**九、位置方法**

**indexOf()和lastIndexOf()：**在当前数组中查找指定项的位置

- 接收2个参数：要查找的项和表示查找起点位置的索引（可选）
- indexOf()从数组开头（位置为0）开始向后查找，lastIndexOf()从数组末尾开始向前查找
- **返回**要查找的项在数组中的位置，没找到则返回-1
- 比较要查找的项（参数一）时，使用全等操作符（===）

**十、迭代方法**

总共有5个迭代方法，每个党法接收2个参数：要在每一项上运行的函数和运行该函数的作用域对象（可选）

传入的函数接收3个参数：数组项的值item、该项在数组中的位置index和数组对象本身array

**every()：**对数组中每一项运行给定函数，如果该函数对每一项都返回true，则返回true

**some()：**对数组中每一项运行给定函数，如果该函数对任一项返回true，则返回true

**filter()：**对数组中每一项运行给定函数，返回该函数会返回true的项组成的数组

**map()：**对数组中每一项运行给定函数，返回每次函数调用的结果组成的数组

**forEach()：**对数组中每一项运行给定函数，没有返回值

**十一、归并方法**

**reduce()和reduceRight()：**迭代数组的所有项，然后构建一个最终返回的值

- reduce()从数组的第一项开始，逐个遍历到最后
- reduceRight()从数组的最后一项开始，向前遍历到第一项
- 都接收2个参数：一个在每一项上调用的函数和作为归并基础的初始值（可选）
- 传入的函数接收4个参数：前一个值prev、当前值cur、项的索引index和数组对象array
	- 这个函数返回的任何值都会作为第一个参数自动传给下一项
	- 第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数是数组的第二项

> 示例

求数组中所有值之和：

    var values = [1,2,3,4,5];
	var sum = values.reduce(function(prev,cur,index,array) {
		return prev = cur;
	});
	console.log(sum);	//15

第一次执行回调函数，prev是1，cur是2。第二次，prev是3（1加2的结果），cur是3（数组的第三项）。这个过程持续把数组中每一项都访问一遍，最后返回结果

#### <span id="GoodeParts01_03"></span>> Date类型 ####

> Date类型使用自UTC（国际协调时间）1970年1月1日午夜（零时）开始经过的毫秒数来保存日期（这种格式的Date类型可以精确到1970年1月1日之前或之后的100 000 000年）

**一、创建日期对象方法：**

	var now = new Date();

在调用Date构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间

**二、根据指定日期返回毫秒数方法：**

如果想根据指定日期和时间创建日期对象，必须传入表示该日期的毫秒数（即从UTC时间1970年1月1日午夜起至该日期止经过的毫秒数），为了简化这一过程，有两个方法：Date.parse()和Date.UTC()

**Date.parse()：**接收一个表示日期的字符串参数，然后根据这个字符串返回相应日期的毫秒数

    var someDate = new Date(Date.parse("May 25, 2004"));	//Tue May 25 2004 00:00:00 GMT+0800 (中国标准时间)

如果传入的字符串不能表示日期，那么返回NaN

如果直接将表示日期的字符串传递给Date构造函数，也会在后台调用Date.parse()

    var someDate = new Date("May 25, 2004");		//Tue May 25 2004 00:00:00 GMT+0800 (中国标准时间)

**Date.UTC()：**接收一个固定格式的表示日期的字符串参数，返回相应日期毫秒数

参数格式：年份、基于0的月份（一月是0，二月是1，以此类推）、月中的哪一天（1到31）、小时数（0到23）、分钟、秒以及毫秒数（只有前两个参数年和月是必需的，如果没有月中的天数，则默认为1，省略其他参数，则统统为0）

    var allFives = new Date(Date.UTC(2016,8,22,21,30,55));	//Fri Sep 23 2016 05:30:55 GMT+0800 (中国标准时间)

**Date.now()：**(IE9+)返回表示调用这个方法时的日期和时间的毫秒数

	//取得开始时间
    var start = Date.now();

	//调用函数
	doSomething();

	//取得停止时间
	var stop = Date.now();
	
	var result = stop - start;

在不支持这个方法的浏览器中，可以使用+操作符获取Date对象的时间戳，达到同样目的

	//取得开始时间
    var start = +Date.now();

	//调用函数
	doSomething();

	//取得停止时间
	var stop = +Date.now();
	
	var result = stop - start;

**三、继承的方法**

**toString()：**返回带有时区信息的日期和时间，其中时间一般以军用时间（即小时的范围是0到23）表示

**toLocaleString()：**按照与浏览器设置的地区相适应的格式返回日期和时间，不包含时区信息

**valueOf()：**不返回字符串，而是返回日期的毫秒表示。方便使用比较操作符（小于或大于）来比较日期值

#### <span id="GoodeParts01_04"></span>> RegExp类型 ####

**一、创建正则表达式：**

1、使用字面量模式

    var expression = /pattern/ flags;

	var pattern1 = /\[bc\]at/i;

> 正则表达式字面量在脚本加载后编译。若你的正则表达式是常量，使用这种方式可以获得更好的性能

- 其中模式（pattern）可以是任何简单或复杂的正则表达式，可以包含字符类、限定类、分组、向前查找以及反向引用
- 每个正则表达式都可以带有一或多个标志（flags），用以表明正则表达式的行为
	- **g：**表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；
	- **i：**表示不区分大小写（case-insensitive）模式，即在确定匹配项是忽略模式与字符串的大小写
	- **m：**表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项
- 模式中使用的所有元字符都必须转义(加`\`)，正则表达式中的元字符包括：
	-  `( )[ ]{ } \ ^ $ | ? * + .`

2、使用RegExp构造函数

    var pattern2 = new RegExp("\\[bc\\]at","i");

> 使用构造函数，提供了对正则表达式运行时的编译。当你知道正则表达式的模式会发生改变， 或者你事先并不了解它的模式或者是从其他地方（比如用户的输入），得到的代码这时比较适合用构造函数的方式

- 接收2个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串（都是字符串）
- 由于函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义，元字符必须双重转义，那些已经转义过的字符也是如此

> 示例

|字面量模式|等价的字符串|
|---|---|
|`/\[bc\]at/`|`"\\[bc\\]at"`|
|`/\.at/`|`\\.at`|
|`/name\/age/`|`name\\/age`|
|`/\d.\d{1,2}/`|`\\d.\\d{1,2}`|
|`/\w\\hello\\123/`|`\\w\\\\hello\\\\123`|

这两种放大创建的正则表达式的**区别：**

- 正则表达式字面量始终会共享同一个RegExp实例（ECMAScript3）
- 构造函数创建的每一个新RegExp实例都是一个新实例
- ECMAScript5规定使用正则表达式必须像直接调用RegExp构造函数一样每次都创建新的实例（IE9+）

**二、RegExp实例属性**

RegExp的每个实例都具有下列属性：

- **global：**布尔值，表示是否设置了g标志
- **ignoreCase：**布尔值，表示是否设置了i标志
- **lastIndex：**整数，表示开始搜索下一个匹配项的字符位置，从0算起
- **multiline：**布尔值，表示是否设置了m标志
- **source：**正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回

**三、RegExp实例方法**

**exec()：**专门为捕获组设计的
